{"ast":null,"code":"var __extends = this && this.t || function () {\n  var extendStatics = function (e, i) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (e, i) {\n      e.__proto__ = i;\n    } || function (e, i) {\n      for (var r in i) if (Object.prototype.hasOwnProperty.call(i, r)) e[r] = i[r];\n    };\n    return extendStatics(e, i);\n  };\n  return function (e, i) {\n    if (typeof i !== \"function\" && i !== null) throw new TypeError(\"Class extends value \" + String(i) + \" is not a constructor or null\");\n    extendStatics(e, i);\n    function __() {\n      this.constructor = e;\n    }\n    e.prototype = i === null ? Object.create(i) : (__.prototype = i.prototype, new __());\n  };\n}();\nimport { TreeNode, TreeNodeEnableIndex } from \"./TreeNode\";\nimport { Container } from \"../../ContainerBase\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = function (e) {\n  __extends(TreeContainer, e);\n  function TreeContainer(i, r) {\n    if (i === void 0) {\n      i = function (e, i) {\n        if (e < i) return -1;\n        if (e > i) return 1;\n        return 0;\n      };\n    }\n    if (r === void 0) {\n      r = false;\n    }\n    var t = e.call(this) || this;\n    t.rr = undefined;\n    t.j = i;\n    t.enableIndex = r;\n    t.re = r ? TreeNodeEnableIndex : TreeNode;\n    t.u = new t.re();\n    return t;\n  }\n  TreeContainer.prototype.$ = function (e, i) {\n    var r = this.u;\n    while (e) {\n      var t = this.j(e.p, i);\n      if (t < 0) {\n        e = e.Z;\n      } else if (t > 0) {\n        r = e;\n        e = e.Y;\n      } else return e;\n    }\n    return r;\n  };\n  TreeContainer.prototype.tr = function (e, i) {\n    var r = this.u;\n    while (e) {\n      var t = this.j(e.p, i);\n      if (t <= 0) {\n        e = e.Z;\n      } else {\n        r = e;\n        e = e.Y;\n      }\n    }\n    return r;\n  };\n  TreeContainer.prototype.er = function (e, i) {\n    var r = this.u;\n    while (e) {\n      var t = this.j(e.p, i);\n      if (t < 0) {\n        r = e;\n        e = e.Z;\n      } else if (t > 0) {\n        e = e.Y;\n      } else return e;\n    }\n    return r;\n  };\n  TreeContainer.prototype.nr = function (e, i) {\n    var r = this.u;\n    while (e) {\n      var t = this.j(e.p, i);\n      if (t < 0) {\n        r = e;\n        e = e.Z;\n      } else {\n        e = e.Y;\n      }\n    }\n    return r;\n  };\n  TreeContainer.prototype.se = function (e) {\n    while (true) {\n      var i = e.sr;\n      if (i === this.u) return;\n      if (e.ee === 1) {\n        e.ee = 0;\n        return;\n      }\n      if (e === i.Y) {\n        var r = i.Z;\n        if (r.ee === 1) {\n          r.ee = 0;\n          i.ee = 1;\n          if (i === this.rr) {\n            this.rr = i.te();\n          } else i.te();\n        } else {\n          if (r.Z && r.Z.ee === 1) {\n            r.ee = i.ee;\n            i.ee = 0;\n            r.Z.ee = 0;\n            if (i === this.rr) {\n              this.rr = i.te();\n            } else i.te();\n            return;\n          } else if (r.Y && r.Y.ee === 1) {\n            r.ee = 1;\n            r.Y.ee = 0;\n            r.ne();\n          } else {\n            r.ee = 1;\n            e = i;\n          }\n        }\n      } else {\n        var r = i.Y;\n        if (r.ee === 1) {\n          r.ee = 0;\n          i.ee = 1;\n          if (i === this.rr) {\n            this.rr = i.ne();\n          } else i.ne();\n        } else {\n          if (r.Y && r.Y.ee === 1) {\n            r.ee = i.ee;\n            i.ee = 0;\n            r.Y.ee = 0;\n            if (i === this.rr) {\n              this.rr = i.ne();\n            } else i.ne();\n            return;\n          } else if (r.Z && r.Z.ee === 1) {\n            r.ee = 1;\n            r.Z.ee = 0;\n            r.te();\n          } else {\n            r.ee = 1;\n            e = i;\n          }\n        }\n      }\n    }\n  };\n  TreeContainer.prototype.U = function (e) {\n    if (this.i === 1) {\n      this.clear();\n      return;\n    }\n    var i = e;\n    while (i.Y || i.Z) {\n      if (i.Z) {\n        i = i.Z;\n        while (i.Y) i = i.Y;\n      } else {\n        i = i.Y;\n      }\n      var r = e.p;\n      e.p = i.p;\n      i.p = r;\n      var t = e.H;\n      e.H = i.H;\n      i.H = t;\n      e = i;\n    }\n    if (this.u.Y === i) {\n      this.u.Y = i.sr;\n    } else if (this.u.Z === i) {\n      this.u.Z = i.sr;\n    }\n    this.se(i);\n    var n = i.sr;\n    if (i === n.Y) {\n      n.Y = undefined;\n    } else n.Z = undefined;\n    this.i -= 1;\n    this.rr.ee = 0;\n    if (this.enableIndex) {\n      while (n !== this.u) {\n        n.hr -= 1;\n        n = n.sr;\n      }\n    }\n  };\n  TreeContainer.prototype.ir = function (e) {\n    var i = typeof e === \"number\" ? e : undefined;\n    var r = typeof e === \"function\" ? e : undefined;\n    var t = typeof e === \"undefined\" ? [] : undefined;\n    var n = 0;\n    var s = this.rr;\n    var f = [];\n    while (f.length || s) {\n      if (s) {\n        f.push(s);\n        s = s.Y;\n      } else {\n        s = f.pop();\n        if (n === i) return s;\n        t && t.push(s);\n        r && r(s, n, this);\n        n += 1;\n        s = s.Z;\n      }\n    }\n    return t;\n  };\n  TreeContainer.prototype.fe = function (e) {\n    while (true) {\n      var i = e.sr;\n      if (i.ee === 0) return;\n      var r = i.sr;\n      if (i === r.Y) {\n        var t = r.Z;\n        if (t && t.ee === 1) {\n          t.ee = i.ee = 0;\n          if (r === this.rr) return;\n          r.ee = 1;\n          e = r;\n          continue;\n        } else if (e === i.Z) {\n          e.ee = 0;\n          if (e.Y) {\n            e.Y.sr = i;\n          }\n          if (e.Z) {\n            e.Z.sr = r;\n          }\n          i.Z = e.Y;\n          r.Y = e.Z;\n          e.Y = i;\n          e.Z = r;\n          if (r === this.rr) {\n            this.rr = e;\n            this.u.sr = e;\n          } else {\n            var n = r.sr;\n            if (n.Y === r) {\n              n.Y = e;\n            } else n.Z = e;\n          }\n          e.sr = r.sr;\n          i.sr = e;\n          r.sr = e;\n          r.ee = 1;\n        } else {\n          i.ee = 0;\n          if (r === this.rr) {\n            this.rr = r.ne();\n          } else r.ne();\n          r.ee = 1;\n          return;\n        }\n      } else {\n        var t = r.Y;\n        if (t && t.ee === 1) {\n          t.ee = i.ee = 0;\n          if (r === this.rr) return;\n          r.ee = 1;\n          e = r;\n          continue;\n        } else if (e === i.Y) {\n          e.ee = 0;\n          if (e.Y) {\n            e.Y.sr = r;\n          }\n          if (e.Z) {\n            e.Z.sr = i;\n          }\n          r.Z = e.Y;\n          i.Y = e.Z;\n          e.Y = r;\n          e.Z = i;\n          if (r === this.rr) {\n            this.rr = e;\n            this.u.sr = e;\n          } else {\n            var n = r.sr;\n            if (n.Y === r) {\n              n.Y = e;\n            } else n.Z = e;\n          }\n          e.sr = r.sr;\n          i.sr = e;\n          r.sr = e;\n          r.ee = 1;\n        } else {\n          i.ee = 0;\n          if (r === this.rr) {\n            this.rr = r.te();\n          } else r.te();\n          r.ee = 1;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        i.ie();\n        r.ie();\n        e.ie();\n      }\n      return;\n    }\n  };\n  TreeContainer.prototype.v = function (e, i, r) {\n    if (this.rr === undefined) {\n      this.i += 1;\n      this.rr = new this.re(e, i, 0);\n      this.rr.sr = this.u;\n      this.u.sr = this.u.Y = this.u.Z = this.rr;\n      return this.i;\n    }\n    var t;\n    var n = this.u.Y;\n    var s = this.j(n.p, e);\n    if (s === 0) {\n      n.H = i;\n      return this.i;\n    } else if (s > 0) {\n      n.Y = new this.re(e, i);\n      n.Y.sr = n;\n      t = n.Y;\n      this.u.Y = t;\n    } else {\n      var f = this.u.Z;\n      var h = this.j(f.p, e);\n      if (h === 0) {\n        f.H = i;\n        return this.i;\n      } else if (h < 0) {\n        f.Z = new this.re(e, i);\n        f.Z.sr = f;\n        t = f.Z;\n        this.u.Z = t;\n      } else {\n        if (r !== undefined) {\n          var u = r.o;\n          if (u !== this.u) {\n            var a = this.j(u.p, e);\n            if (a === 0) {\n              u.H = i;\n              return this.i;\n            } else if (a > 0) {\n              var o = u.L();\n              var l = this.j(o.p, e);\n              if (l === 0) {\n                o.H = i;\n                return this.i;\n              } else if (l < 0) {\n                t = new this.re(e, i);\n                if (o.Z === undefined) {\n                  o.Z = t;\n                  t.sr = o;\n                } else {\n                  u.Y = t;\n                  t.sr = u;\n                }\n              }\n            }\n          }\n        }\n        if (t === undefined) {\n          t = this.rr;\n          while (true) {\n            var v = this.j(t.p, e);\n            if (v > 0) {\n              if (t.Y === undefined) {\n                t.Y = new this.re(e, i);\n                t.Y.sr = t;\n                t = t.Y;\n                break;\n              }\n              t = t.Y;\n            } else if (v < 0) {\n              if (t.Z === undefined) {\n                t.Z = new this.re(e, i);\n                t.Z.sr = t;\n                t = t.Z;\n                break;\n              }\n              t = t.Z;\n            } else {\n              t.H = i;\n              return this.i;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      var d = t.sr;\n      while (d !== this.u) {\n        d.hr += 1;\n        d = d.sr;\n      }\n    }\n    this.fe(t);\n    this.i += 1;\n    return this.i;\n  };\n  TreeContainer.prototype.ar = function (e, i) {\n    while (e) {\n      var r = this.j(e.p, i);\n      if (r < 0) {\n        e = e.Z;\n      } else if (r > 0) {\n        e = e.Y;\n      } else return e;\n    }\n    return e || this.u;\n  };\n  TreeContainer.prototype.clear = function () {\n    this.i = 0;\n    this.rr = undefined;\n    this.u.sr = undefined;\n    this.u.Y = this.u.Z = undefined;\n  };\n  TreeContainer.prototype.updateKeyByIterator = function (e, i) {\n    var r = e.o;\n    if (r === this.u) {\n      throwIteratorAccessError();\n    }\n    if (this.i === 1) {\n      r.p = i;\n      return true;\n    }\n    var t = r.m().p;\n    if (r === this.u.Y) {\n      if (this.j(t, i) > 0) {\n        r.p = i;\n        return true;\n      }\n      return false;\n    }\n    var n = r.L().p;\n    if (r === this.u.Z) {\n      if (this.j(n, i) < 0) {\n        r.p = i;\n        return true;\n      }\n      return false;\n    }\n    if (this.j(n, i) >= 0 || this.j(t, i) <= 0) return false;\n    r.p = i;\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByPos = function (e) {\n    if (e < 0 || e > this.i - 1) {\n      throw new RangeError();\n    }\n    var i = this.ir(e);\n    this.U(i);\n    return this.i;\n  };\n  TreeContainer.prototype.eraseElementByKey = function (e) {\n    if (this.i === 0) return false;\n    var i = this.ar(this.rr, e);\n    if (i === this.u) return false;\n    this.U(i);\n    return true;\n  };\n  TreeContainer.prototype.eraseElementByIterator = function (e) {\n    var i = e.o;\n    if (i === this.u) {\n      throwIteratorAccessError();\n    }\n    var r = i.Z === undefined;\n    var t = e.iteratorType === 0;\n    if (t) {\n      if (r) e.next();\n    } else {\n      if (!r || i.Y === undefined) e.next();\n    }\n    this.U(i);\n    return e;\n  };\n  TreeContainer.prototype.getHeight = function () {\n    if (this.i === 0) return 0;\n    function traversal(e) {\n      if (!e) return 0;\n      return Math.max(traversal(e.Y), traversal(e.Z)) + 1;\n    }\n    return traversal(this.rr);\n  };\n  return TreeContainer;\n}(Container);\nexport default TreeContainer;","map":{"version":3,"names":["__extends","t","extendStatics","e","i","Object","setPrototypeOf","__proto__","Array","r","prototype","hasOwnProperty","call","TypeError","String","__","constructor","create","TreeNode","TreeNodeEnableIndex","Container","throwIteratorAccessError","TreeContainer","cmp","rr","undefined","j","enableIndex","re","u","$","p","Z","Y","tr","er","nr","se","sr","ee","te","ne","U","clear","H","n","hr","ir","s","f","length","push","pop","fe","ie","v","h","o","a","L","l","d","ar","updateKeyByIterator","m","eraseElementByPos","RangeError","eraseElementByKey","eraseElementByIterator","iteratorType","next","getHeight","traversal","Math","max"],"sources":["/Users/aliosmanhekimoglu/Desktop/REACT_PROJECTS/youtube_clone/node_modules/js-sdsl/dist/esm/container/TreeContainer/Base/container/TreeContainer/Base/index.js","/Users/aliosmanhekimoglu/Desktop/REACT_PROJECTS/youtube_clone/node_modules/js-sdsl/dist/esm/container/src/container/TreeContainer/Base/index.ts"],"sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        if (typeof b !== \"function\" && b !== null)\n            throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nimport { TreeNode, TreeNodeEnableIndex } from './TreeNode';\nimport { Container } from \"../../ContainerBase\";\nimport $checkWithinAccessParams from \"../../../utils/checkParams.macro\";\nimport { throwIteratorAccessError } from \"../../../utils/throwError\";\nvar TreeContainer = /** @class */ (function (_super) {\n    __extends(TreeContainer, _super);\n    /**\n     * @internal\n     */\n    function TreeContainer(cmp, enableIndex) {\n        if (cmp === void 0) { cmp = function (x, y) {\n            if (x < y)\n                return -1;\n            if (x > y)\n                return 1;\n            return 0;\n        }; }\n        if (enableIndex === void 0) { enableIndex = false; }\n        var _this = _super.call(this) || this;\n        /**\n         * @internal\n         */\n        _this._root = undefined;\n        _this._cmp = cmp;\n        _this.enableIndex = enableIndex;\n        _this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n        _this._header = new _this._TreeNodeClass();\n        return _this;\n    }\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._lowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._upperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult <= 0) {\n                curNode = curNode._right;\n            }\n            else {\n                resNode = curNode;\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseLowerBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._reverseUpperBound = function (curNode, key) {\n        var resNode = this._header;\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                resNode = curNode;\n                curNode = curNode._right;\n            }\n            else {\n                curNode = curNode._left;\n            }\n        }\n        return resNode;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode === this._header)\n                return;\n            if (curNode._color === 1 /* TreeNodeColor.RED */) {\n                curNode._color = 0 /* TreeNodeColor.BLACK */;\n                return;\n            }\n            if (curNode === parentNode._left) {\n                var brother = parentNode._right;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateLeft();\n                    }\n                    else\n                        parentNode._rotateLeft();\n                }\n                else {\n                    if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateLeft();\n                        }\n                        else\n                            parentNode._rotateLeft();\n                        return;\n                    }\n                    else if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateRight();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n            else {\n                var brother = parentNode._left;\n                if (brother._color === 1 /* TreeNodeColor.RED */) {\n                    brother._color = 0 /* TreeNodeColor.BLACK */;\n                    parentNode._color = 1 /* TreeNodeColor.RED */;\n                    if (parentNode === this._root) {\n                        this._root = parentNode._rotateRight();\n                    }\n                    else\n                        parentNode._rotateRight();\n                }\n                else {\n                    if (brother._left && brother._left._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = parentNode._color;\n                        parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._left._color = 0 /* TreeNodeColor.BLACK */;\n                        if (parentNode === this._root) {\n                            this._root = parentNode._rotateRight();\n                        }\n                        else\n                            parentNode._rotateRight();\n                        return;\n                    }\n                    else if (brother._right && brother._right._color === 1 /* TreeNodeColor.RED */) {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        brother._right._color = 0 /* TreeNodeColor.BLACK */;\n                        brother._rotateLeft();\n                    }\n                    else {\n                        brother._color = 1 /* TreeNodeColor.RED */;\n                        curNode = parentNode;\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._eraseNode = function (curNode) {\n        if (this._length === 1) {\n            this.clear();\n            return;\n        }\n        var swapNode = curNode;\n        while (swapNode._left || swapNode._right) {\n            if (swapNode._right) {\n                swapNode = swapNode._right;\n                while (swapNode._left)\n                    swapNode = swapNode._left;\n            }\n            else {\n                swapNode = swapNode._left;\n            }\n            var key = curNode._key;\n            curNode._key = swapNode._key;\n            swapNode._key = key;\n            var value = curNode._value;\n            curNode._value = swapNode._value;\n            swapNode._value = value;\n            curNode = swapNode;\n        }\n        if (this._header._left === swapNode) {\n            this._header._left = swapNode._parent;\n        }\n        else if (this._header._right === swapNode) {\n            this._header._right = swapNode._parent;\n        }\n        this._eraseNodeSelfBalance(swapNode);\n        var _parent = swapNode._parent;\n        if (swapNode === _parent._left) {\n            _parent._left = undefined;\n        }\n        else\n            _parent._right = undefined;\n        this._length -= 1;\n        this._root._color = 0 /* TreeNodeColor.BLACK */;\n        if (this.enableIndex) {\n            while (_parent !== this._header) {\n                _parent._subTreeSize -= 1;\n                _parent = _parent._parent;\n            }\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._inOrderTraversal = function (param) {\n        var pos = typeof param === 'number' ? param : undefined;\n        var callback = typeof param === 'function' ? param : undefined;\n        var nodeList = typeof param === 'undefined' ? [] : undefined;\n        var index = 0;\n        var curNode = this._root;\n        var stack = [];\n        while (stack.length || curNode) {\n            if (curNode) {\n                stack.push(curNode);\n                curNode = curNode._left;\n            }\n            else {\n                curNode = stack.pop();\n                if (index === pos)\n                    return curNode;\n                nodeList && nodeList.push(curNode);\n                callback && callback(curNode, index, this);\n                index += 1;\n                curNode = curNode._right;\n            }\n        }\n        return nodeList;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._insertNodeSelfBalance = function (curNode) {\n        while (true) {\n            var parentNode = curNode._parent;\n            if (parentNode._color === 0 /* TreeNodeColor.BLACK */)\n                return;\n            var grandParent = parentNode._parent;\n            if (parentNode === grandParent._left) {\n                var uncle = grandParent._right;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._right) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = parentNode;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = grandParent;\n                    }\n                    parentNode._right = curNode._left;\n                    grandParent._left = curNode._right;\n                    curNode._left = parentNode;\n                    curNode._right = grandParent;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateRight();\n                    }\n                    else\n                        grandParent._rotateRight();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            else {\n                var uncle = grandParent._left;\n                if (uncle && uncle._color === 1 /* TreeNodeColor.RED */) {\n                    uncle._color = parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root)\n                        return;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    curNode = grandParent;\n                    continue;\n                }\n                else if (curNode === parentNode._left) {\n                    curNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (curNode._left) {\n                        curNode._left._parent = grandParent;\n                    }\n                    if (curNode._right) {\n                        curNode._right._parent = parentNode;\n                    }\n                    grandParent._right = curNode._left;\n                    parentNode._left = curNode._right;\n                    curNode._left = grandParent;\n                    curNode._right = parentNode;\n                    if (grandParent === this._root) {\n                        this._root = curNode;\n                        this._header._parent = curNode;\n                    }\n                    else {\n                        var GP = grandParent._parent;\n                        if (GP._left === grandParent) {\n                            GP._left = curNode;\n                        }\n                        else\n                            GP._right = curNode;\n                    }\n                    curNode._parent = grandParent._parent;\n                    parentNode._parent = curNode;\n                    grandParent._parent = curNode;\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                }\n                else {\n                    parentNode._color = 0 /* TreeNodeColor.BLACK */;\n                    if (grandParent === this._root) {\n                        this._root = grandParent._rotateLeft();\n                    }\n                    else\n                        grandParent._rotateLeft();\n                    grandParent._color = 1 /* TreeNodeColor.RED */;\n                    return;\n                }\n            }\n            if (this.enableIndex) {\n                parentNode._recount();\n                grandParent._recount();\n                curNode._recount();\n            }\n            return;\n        }\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._set = function (key, value, hint) {\n        if (this._root === undefined) {\n            this._length += 1;\n            this._root = new this._TreeNodeClass(key, value, 0 /* TreeNodeColor.BLACK */);\n            this._root._parent = this._header;\n            this._header._parent = this._header._left = this._header._right = this._root;\n            return this._length;\n        }\n        var curNode;\n        var minNode = this._header._left;\n        var compareToMin = this._cmp(minNode._key, key);\n        if (compareToMin === 0) {\n            minNode._value = value;\n            return this._length;\n        }\n        else if (compareToMin > 0) {\n            minNode._left = new this._TreeNodeClass(key, value);\n            minNode._left._parent = minNode;\n            curNode = minNode._left;\n            this._header._left = curNode;\n        }\n        else {\n            var maxNode = this._header._right;\n            var compareToMax = this._cmp(maxNode._key, key);\n            if (compareToMax === 0) {\n                maxNode._value = value;\n                return this._length;\n            }\n            else if (compareToMax < 0) {\n                maxNode._right = new this._TreeNodeClass(key, value);\n                maxNode._right._parent = maxNode;\n                curNode = maxNode._right;\n                this._header._right = curNode;\n            }\n            else {\n                if (hint !== undefined) {\n                    var iterNode = hint._node;\n                    if (iterNode !== this._header) {\n                        var iterCmpRes = this._cmp(iterNode._key, key);\n                        if (iterCmpRes === 0) {\n                            iterNode._value = value;\n                            return this._length;\n                        }\n                        else /* istanbul ignore else */ if (iterCmpRes > 0) {\n                            var preNode = iterNode._pre();\n                            var preCmpRes = this._cmp(preNode._key, key);\n                            if (preCmpRes === 0) {\n                                preNode._value = value;\n                                return this._length;\n                            }\n                            else if (preCmpRes < 0) {\n                                curNode = new this._TreeNodeClass(key, value);\n                                if (preNode._right === undefined) {\n                                    preNode._right = curNode;\n                                    curNode._parent = preNode;\n                                }\n                                else {\n                                    iterNode._left = curNode;\n                                    curNode._parent = iterNode;\n                                }\n                            }\n                        }\n                    }\n                }\n                if (curNode === undefined) {\n                    curNode = this._root;\n                    while (true) {\n                        var cmpResult = this._cmp(curNode._key, key);\n                        if (cmpResult > 0) {\n                            if (curNode._left === undefined) {\n                                curNode._left = new this._TreeNodeClass(key, value);\n                                curNode._left._parent = curNode;\n                                curNode = curNode._left;\n                                break;\n                            }\n                            curNode = curNode._left;\n                        }\n                        else if (cmpResult < 0) {\n                            if (curNode._right === undefined) {\n                                curNode._right = new this._TreeNodeClass(key, value);\n                                curNode._right._parent = curNode;\n                                curNode = curNode._right;\n                                break;\n                            }\n                            curNode = curNode._right;\n                        }\n                        else {\n                            curNode._value = value;\n                            return this._length;\n                        }\n                    }\n                }\n            }\n        }\n        if (this.enableIndex) {\n            var parent_1 = curNode._parent;\n            while (parent_1 !== this._header) {\n                parent_1._subTreeSize += 1;\n                parent_1 = parent_1._parent;\n            }\n        }\n        this._insertNodeSelfBalance(curNode);\n        this._length += 1;\n        return this._length;\n    };\n    /**\n     * @internal\n     */\n    TreeContainer.prototype._getTreeNodeByKey = function (curNode, key) {\n        while (curNode) {\n            var cmpResult = this._cmp(curNode._key, key);\n            if (cmpResult < 0) {\n                curNode = curNode._right;\n            }\n            else if (cmpResult > 0) {\n                curNode = curNode._left;\n            }\n            else\n                return curNode;\n        }\n        return curNode || this._header;\n    };\n    TreeContainer.prototype.clear = function () {\n        this._length = 0;\n        this._root = undefined;\n        this._header._parent = undefined;\n        this._header._left = this._header._right = undefined;\n    };\n    /**\n     * @description Update node's key by iterator.\n     * @param iter - The iterator you want to change.\n     * @param key - The key you want to update.\n     * @returns Whether the modification is successful.\n     * @example\n     * const st = new orderedSet([1, 2, 5]);\n     * const iter = st.find(2);\n     * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n     */\n    TreeContainer.prototype.updateKeyByIterator = function (iter, key) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        if (this._length === 1) {\n            node._key = key;\n            return true;\n        }\n        var nextKey = node._next()._key;\n        if (node === this._header._left) {\n            if (this._cmp(nextKey, key) > 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        var preKey = node._pre()._key;\n        if (node === this._header._right) {\n            if (this._cmp(preKey, key) < 0) {\n                node._key = key;\n                return true;\n            }\n            return false;\n        }\n        if (this._cmp(preKey, key) >= 0 ||\n            this._cmp(nextKey, key) <= 0)\n            return false;\n        node._key = key;\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByPos = function (pos) {\n        if (pos < 0 || pos > this._length - 1) {\n            throw new RangeError();\n        }\n        var node = this._inOrderTraversal(pos);\n        this._eraseNode(node);\n        return this._length;\n    };\n    /**\n     * @description Remove the element of the specified key.\n     * @param key - The key you want to remove.\n     * @returns Whether erase successfully.\n     */\n    TreeContainer.prototype.eraseElementByKey = function (key) {\n        if (this._length === 0)\n            return false;\n        var curNode = this._getTreeNodeByKey(this._root, key);\n        if (curNode === this._header)\n            return false;\n        this._eraseNode(curNode);\n        return true;\n    };\n    TreeContainer.prototype.eraseElementByIterator = function (iter) {\n        var node = iter._node;\n        if (node === this._header) {\n            throwIteratorAccessError();\n        }\n        var hasNoRight = node._right === undefined;\n        var isNormal = iter.iteratorType === 0 /* IteratorType.NORMAL */;\n        // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n        if (isNormal) {\n            // So we should move it to next when it's right is null.\n            if (hasNoRight)\n                iter.next();\n        }\n        else {\n            // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n            // So when it has right, or it is a leaf node we should move it to `next`.\n            if (!hasNoRight || node._left === undefined)\n                iter.next();\n        }\n        this._eraseNode(node);\n        return iter;\n    };\n    /**\n     * @description Get the height of the tree.\n     * @returns Number about the height of the RB-tree.\n     */\n    TreeContainer.prototype.getHeight = function () {\n        if (this._length === 0)\n            return 0;\n        function traversal(curNode) {\n            if (!curNode)\n                return 0;\n            return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n        }\n        return traversal(this._root);\n    };\n    return TreeContainer;\n}(Container));\nexport default TreeContainer;\n","import type TreeIterator from './TreeIterator';\nimport { TreeNode, TreeNodeColor, TreeNodeEnableIndex } from './TreeNode';\nimport { Container, IteratorType } from '@/container/ContainerBase';\nimport $checkWithinAccessParams from '@/utils/checkParams.macro';\nimport { throwIteratorAccessError } from '@/utils/throwError';\n\nabstract class TreeContainer<K, V> extends Container<K | [K, V]> {\n  enableIndex: boolean;\n  /**\n   * @internal\n   */\n  protected _header: TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _root: TreeNode<K, V> | undefined = undefined;\n  /**\n   * @internal\n   */\n  protected readonly _cmp: (x: K, y: K) => number;\n  /**\n   * @internal\n   */\n  protected readonly _TreeNodeClass: typeof TreeNode | typeof TreeNodeEnableIndex;\n  /**\n   * @internal\n   */\n  protected constructor(\n    cmp: (x: K, y: K) => number =\n    function (x: K, y: K) {\n      if (x < y) return -1;\n      if (x > y) return 1;\n      return 0;\n    },\n    enableIndex = false\n  ) {\n    super();\n    this._cmp = cmp;\n    this.enableIndex = enableIndex;\n    this._TreeNodeClass = enableIndex ? TreeNodeEnableIndex : TreeNode;\n    this._header = new this._TreeNodeClass();\n  }\n  /**\n   * @internal\n   */\n  protected _lowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        resNode = curNode;\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _upperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult <= 0) {\n        curNode = curNode._right;\n      } else {\n        resNode = curNode;\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseLowerBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _reverseUpperBound(curNode: TreeNode<K, V> | undefined, key: K) {\n    let resNode = this._header;\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        resNode = curNode;\n        curNode = curNode._right;\n      } else {\n        curNode = curNode._left;\n      }\n    }\n    return resNode;\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode === this._header) return;\n      if (curNode._color === TreeNodeColor.RED) {\n        curNode._color = TreeNodeColor.BLACK;\n        return;\n      }\n      if (curNode === parentNode._left) {\n        const brother = parentNode._right!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateLeft();\n          } else parentNode._rotateLeft();\n        } else {\n          if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._right._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateLeft();\n            } else parentNode._rotateLeft();\n            return;\n          } else if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._left._color = TreeNodeColor.BLACK;\n            brother._rotateRight();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      } else {\n        const brother = parentNode._left!;\n        if (brother._color === TreeNodeColor.RED) {\n          brother._color = TreeNodeColor.BLACK;\n          parentNode._color = TreeNodeColor.RED;\n          if (parentNode === this._root) {\n            this._root = parentNode._rotateRight();\n          } else parentNode._rotateRight();\n        } else {\n          if (brother._left && brother._left._color === TreeNodeColor.RED) {\n            brother._color = parentNode._color;\n            parentNode._color = TreeNodeColor.BLACK;\n            brother._left._color = TreeNodeColor.BLACK;\n            if (parentNode === this._root) {\n              this._root = parentNode._rotateRight();\n            } else parentNode._rotateRight();\n            return;\n          } else if (brother._right && brother._right._color === TreeNodeColor.RED) {\n            brother._color = TreeNodeColor.RED;\n            brother._right._color = TreeNodeColor.BLACK;\n            brother._rotateLeft();\n          } else {\n            brother._color = TreeNodeColor.RED;\n            curNode = parentNode;\n          }\n        }\n      }\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _eraseNode(curNode: TreeNode<K, V>) {\n    if (this._length === 1) {\n      this.clear();\n      return;\n    }\n    let swapNode = curNode;\n    while (swapNode._left || swapNode._right) {\n      if (swapNode._right) {\n        swapNode = swapNode._right;\n        while (swapNode._left) swapNode = swapNode._left;\n      } else {\n        swapNode = swapNode._left!;\n      }\n      const key = curNode._key;\n      curNode._key = swapNode._key;\n      swapNode._key = key;\n      const value = curNode._value;\n      curNode._value = swapNode._value;\n      swapNode._value = value;\n      curNode = swapNode;\n    }\n    if (this._header._left === swapNode) {\n      this._header._left = swapNode._parent;\n    } else if (this._header._right === swapNode) {\n      this._header._right = swapNode._parent;\n    }\n    this._eraseNodeSelfBalance(swapNode);\n    let _parent = swapNode._parent as TreeNodeEnableIndex<K, V>;\n    if (swapNode === _parent._left) {\n      _parent._left = undefined;\n    } else _parent._right = undefined;\n    this._length -= 1;\n    this._root!._color = TreeNodeColor.BLACK;\n    if (this.enableIndex) {\n      while (_parent !== this._header) {\n        _parent._subTreeSize -= 1;\n        _parent = _parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n  }\n  protected _inOrderTraversal(): TreeNode<K, V>[];\n  protected _inOrderTraversal(pos: number): TreeNode<K, V>;\n  protected _inOrderTraversal(\n    callback: (node: TreeNode<K, V>, index: number, map: this) => void\n  ): TreeNode<K, V>;\n  /**\n   * @internal\n   */\n  protected _inOrderTraversal(\n    param?: number | ((node: TreeNode<K, V>, index: number, map: this) => void)\n  ) {\n    const pos = typeof param === 'number' ? param : undefined;\n    const callback = typeof param === 'function' ? param : undefined;\n    const nodeList = typeof param === 'undefined' ? <TreeNode<K, V>[]>[] : undefined;\n    let index = 0;\n    let curNode = this._root;\n    const stack: TreeNode<K, V>[] = [];\n    while (stack.length || curNode) {\n      if (curNode) {\n        stack.push(curNode);\n        curNode = curNode._left;\n      } else {\n        curNode = stack.pop()!;\n        if (index === pos) return curNode;\n        nodeList && nodeList.push(curNode);\n        callback && callback(curNode, index, this);\n        index += 1;\n        curNode = curNode._right;\n      }\n    }\n    return nodeList;\n  }\n  /**\n   * @internal\n   */\n  protected _insertNodeSelfBalance(curNode: TreeNode<K, V>) {\n    while (true) {\n      const parentNode = curNode._parent!;\n      if (parentNode._color === TreeNodeColor.BLACK) return;\n      const grandParent = parentNode._parent!;\n      if (parentNode === grandParent._left) {\n        const uncle = grandParent._right;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._right) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = parentNode;\n          }\n          if (curNode._right) {\n            curNode._right._parent = grandParent;\n          }\n          parentNode._right = curNode._left;\n          grandParent._left = curNode._right;\n          curNode._left = parentNode;\n          curNode._right = grandParent;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateRight();\n          } else grandParent._rotateRight();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      } else {\n        const uncle = grandParent._left;\n        if (uncle && uncle._color === TreeNodeColor.RED) {\n          uncle._color = parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) return;\n          grandParent._color = TreeNodeColor.RED;\n          curNode = grandParent;\n          continue;\n        } else if (curNode === parentNode._left) {\n          curNode._color = TreeNodeColor.BLACK;\n          if (curNode._left) {\n            curNode._left._parent = grandParent;\n          }\n          if (curNode._right) {\n            curNode._right._parent = parentNode;\n          }\n          grandParent._right = curNode._left;\n          parentNode._left = curNode._right;\n          curNode._left = grandParent;\n          curNode._right = parentNode;\n          if (grandParent === this._root) {\n            this._root = curNode;\n            this._header._parent = curNode;\n          } else {\n            const GP = grandParent._parent!;\n            if (GP._left === grandParent) {\n              GP._left = curNode;\n            } else GP._right = curNode;\n          }\n          curNode._parent = grandParent._parent;\n          parentNode._parent = curNode;\n          grandParent._parent = curNode;\n          grandParent._color = TreeNodeColor.RED;\n        } else {\n          parentNode._color = TreeNodeColor.BLACK;\n          if (grandParent === this._root) {\n            this._root = grandParent._rotateLeft();\n          } else grandParent._rotateLeft();\n          grandParent._color = TreeNodeColor.RED;\n          return;\n        }\n      }\n      if (this.enableIndex) {\n        (<TreeNodeEnableIndex<K, V>>parentNode)._recount();\n        (<TreeNodeEnableIndex<K, V>>grandParent)._recount();\n        (<TreeNodeEnableIndex<K, V>>curNode)._recount();\n      }\n      return;\n    }\n  }\n  /**\n   * @internal\n   */\n  protected _set(key: K, value?: V, hint?: TreeIterator<K, V>) {\n    if (this._root === undefined) {\n      this._length += 1;\n      this._root = new this._TreeNodeClass(key, value, TreeNodeColor.BLACK);\n      this._root._parent = this._header;\n      this._header._parent = this._header._left = this._header._right = this._root;\n      return this._length;\n    }\n    let curNode;\n    const minNode = this._header._left!;\n    const compareToMin = this._cmp(minNode._key!, key);\n    if (compareToMin === 0) {\n      minNode._value = value;\n      return this._length;\n    } else if (compareToMin > 0) {\n      minNode._left = new this._TreeNodeClass(key, value);\n      minNode._left._parent = minNode;\n      curNode = minNode._left;\n      this._header._left = curNode;\n    } else {\n      const maxNode = this._header._right!;\n      const compareToMax = this._cmp(maxNode._key!, key);\n      if (compareToMax === 0) {\n        maxNode._value = value;\n        return this._length;\n      } else if (compareToMax < 0) {\n        maxNode._right = new this._TreeNodeClass(key, value);\n        maxNode._right._parent = maxNode;\n        curNode = maxNode._right;\n        this._header._right = curNode;\n      } else {\n        if (hint !== undefined) {\n          const iterNode = hint._node;\n          if (iterNode !== this._header) {\n            const iterCmpRes = this._cmp(iterNode._key!, key);\n            if (iterCmpRes === 0) {\n              iterNode._value = value;\n              return this._length;\n            } else /* istanbul ignore else */ if (iterCmpRes > 0) {\n              const preNode = iterNode._pre();\n              const preCmpRes = this._cmp(preNode._key!, key);\n              if (preCmpRes === 0) {\n                preNode._value = value;\n                return this._length;\n              } else if (preCmpRes < 0) {\n                curNode = new this._TreeNodeClass(key, value);\n                if (preNode._right === undefined) {\n                  preNode._right = curNode;\n                  curNode._parent = preNode;\n                } else {\n                  iterNode._left = curNode;\n                  curNode._parent = iterNode;\n                }\n              }\n            }\n          }\n        }\n        if (curNode === undefined) {\n          curNode = this._root;\n          while (true) {\n            const cmpResult = this._cmp(curNode._key!, key);\n            if (cmpResult > 0) {\n              if (curNode._left === undefined) {\n                curNode._left = new this._TreeNodeClass(key, value);\n                curNode._left._parent = curNode;\n                curNode = curNode._left;\n                break;\n              }\n              curNode = curNode._left;\n            } else if (cmpResult < 0) {\n              if (curNode._right === undefined) {\n                curNode._right = new this._TreeNodeClass(key, value);\n                curNode._right._parent = curNode;\n                curNode = curNode._right;\n                break;\n              }\n              curNode = curNode._right;\n            } else {\n              curNode._value = value;\n              return this._length;\n            }\n          }\n        }\n      }\n    }\n    if (this.enableIndex) {\n      let parent = curNode._parent as TreeNodeEnableIndex<K, V>;\n      while (parent !== this._header) {\n        parent._subTreeSize += 1;\n        parent = parent._parent as TreeNodeEnableIndex<K, V>;\n      }\n    }\n    this._insertNodeSelfBalance(curNode);\n    this._length += 1;\n    return this._length;\n  }\n  /**\n   * @internal\n   */\n  protected _getTreeNodeByKey(curNode: TreeNode<K, V> | undefined, key: K) {\n    while (curNode) {\n      const cmpResult = this._cmp(curNode._key!, key);\n      if (cmpResult < 0) {\n        curNode = curNode._right;\n      } else if (cmpResult > 0) {\n        curNode = curNode._left;\n      } else return curNode;\n    }\n    return curNode || this._header;\n  }\n  clear() {\n    this._length = 0;\n    this._root = undefined;\n    this._header._parent = undefined;\n    this._header._left = this._header._right = undefined;\n  }\n  /**\n   * @description Update node's key by iterator.\n   * @param iter - The iterator you want to change.\n   * @param key - The key you want to update.\n   * @returns Whether the modification is successful.\n   * @example\n   * const st = new orderedSet([1, 2, 5]);\n   * const iter = st.find(2);\n   * st.updateKeyByIterator(iter, 3); // then st will become [1, 3, 5]\n   */\n  updateKeyByIterator(iter: TreeIterator<K, V>, key: K): boolean {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    if (this._length === 1) {\n      node._key = key;\n      return true;\n    }\n    const nextKey = node._next()._key!;\n    if (node === this._header._left) {\n      if (this._cmp(nextKey, key) > 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    const preKey = node._pre()._key!;\n    if (node === this._header._right) {\n      if (this._cmp(preKey, key) < 0) {\n        node._key = key;\n        return true;\n      }\n      return false;\n    }\n    if (\n      this._cmp(preKey, key) >= 0 ||\n      this._cmp(nextKey, key) <= 0\n    ) return false;\n    node._key = key;\n    return true;\n  }\n  eraseElementByPos(pos: number) {\n    $checkWithinAccessParams!(pos, 0, this._length - 1);\n    const node = this._inOrderTraversal(pos);\n    this._eraseNode(node);\n    return this._length;\n  }\n  /**\n   * @description Remove the element of the specified key.\n   * @param key - The key you want to remove.\n   * @returns Whether erase successfully.\n   */\n  eraseElementByKey(key: K) {\n    if (this._length === 0) return false;\n    const curNode = this._getTreeNodeByKey(this._root, key);\n    if (curNode === this._header) return false;\n    this._eraseNode(curNode);\n    return true;\n  }\n  eraseElementByIterator(iter: TreeIterator<K, V>) {\n    const node = iter._node;\n    if (node === this._header) {\n      throwIteratorAccessError();\n    }\n    const hasNoRight = node._right === undefined;\n    const isNormal = iter.iteratorType === IteratorType.NORMAL;\n    // For the normal iterator, the `next` node will be swapped to `this` node when has right.\n    if (isNormal) {\n      // So we should move it to next when it's right is null.\n      if (hasNoRight) iter.next();\n    } else {\n      // For the reverse iterator, only when it doesn't have right and has left the `next` node will be swapped.\n      // So when it has right, or it is a leaf node we should move it to `next`.\n      if (!hasNoRight || node._left === undefined) iter.next();\n    }\n    this._eraseNode(node);\n    return iter;\n  }\n  /**\n   * @description Get the height of the tree.\n   * @returns Number about the height of the RB-tree.\n   */\n  getHeight() {\n    if (this._length === 0) return 0;\n    function traversal(curNode: TreeNode<K, V> | undefined): number {\n      if (!curNode) return 0;\n      return Math.max(traversal(curNode._left), traversal(curNode._right)) + 1;\n    }\n    return traversal(this._root);\n  }\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element less than the given key.\n   */\n  abstract reverseUpperBound(key: K): TreeIterator<K, V>;\n  /**\n   * @description Union the other tree to self.\n   * @param other - The other tree container you want to merge.\n   * @returns The size of the tree after union.\n   */\n  abstract union(other: TreeContainer<K, V>): number;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not greater than the given key.\n   */\n  abstract reverseLowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element not less than the given key.\n   */\n  abstract lowerBound(key: K): TreeIterator<K, V>;\n  /**\n   * @param key - The given key you want to compare.\n   * @returns An iterator to the first element greater than the given key.\n   */\n  abstract upperBound(key: K): TreeIterator<K, V>;\n}\n\nexport default TreeContainer;\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}